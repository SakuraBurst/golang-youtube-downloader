package youtube

import (
	"context"
	"encoding/xml"
	"fmt"
	"html"
	"io"
	"net/http"
	"strconv"
	"strings"
)

// CaptionTrack represents a single caption/subtitle track for a video.
type CaptionTrack struct {
	// URL is the URL to download the caption track.
	URL string

	// LanguageCode is the ISO 639-1 language code (e.g., "en", "es", "fr").
	LanguageCode string

	// LanguageName is the human-readable name of the language (e.g., "English", "Spanish").
	LanguageName string

	// IsAutoGenerated indicates if the track was auto-generated by YouTube.
	IsAutoGenerated bool

	// IsTranslatable indicates if the track can be translated to other languages.
	IsTranslatable bool
}

// CaptionManifest contains all available caption tracks for a video.
type CaptionManifest struct {
	// Tracks contains all available caption tracks.
	Tracks []CaptionTrack
}

// HasCaptions returns true if any caption tracks are available.
func (m *CaptionManifest) HasCaptions() bool {
	return len(m.Tracks) > 0
}

// GetTrackByLanguage returns the caption track for the specified language code.
// Returns nil if no track is found for the language.
func (m *CaptionManifest) GetTrackByLanguage(languageCode string) *CaptionTrack {
	for i := range m.Tracks {
		if m.Tracks[i].LanguageCode == languageCode {
			return &m.Tracks[i]
		}
	}
	return nil
}

// GetManualTracks returns only manually created (non-auto-generated) caption tracks.
func (m *CaptionManifest) GetManualTracks() []CaptionTrack {
	var tracks []CaptionTrack
	for _, t := range m.Tracks {
		if !t.IsAutoGenerated {
			tracks = append(tracks, t)
		}
	}
	return tracks
}

// GetAutoGeneratedTracks returns only auto-generated caption tracks.
func (m *CaptionManifest) GetAutoGeneratedTracks() []CaptionTrack {
	var tracks []CaptionTrack
	for _, t := range m.Tracks {
		if t.IsAutoGenerated {
			tracks = append(tracks, t)
		}
	}
	return tracks
}

// CaptionFormat represents the output format for captions.
type CaptionFormat string

const (
	// CaptionFormatSRT represents the SubRip format (.srt).
	CaptionFormatSRT CaptionFormat = "srt"
	// CaptionFormatVTT represents the WebVTT format (.vtt).
	CaptionFormatVTT CaptionFormat = "vtt"
)

// CaptionLine represents a single line of caption text with timing.
type CaptionLine struct {
	// Start is the start time in seconds.
	Start float64
	// Duration is the duration in seconds.
	Duration float64
	// Text is the caption text content.
	Text string
}

// End returns the end time in seconds.
func (c *CaptionLine) End() float64 {
	return c.Start + c.Duration
}

// CaptionData represents parsed caption content.
type CaptionData struct {
	// Lines contains all caption lines.
	Lines []CaptionLine
}

// ToSRT converts the caption data to SRT format.
func (cd *CaptionData) ToSRT() string {
	var sb strings.Builder
	for i, line := range cd.Lines {
		sb.WriteString(fmt.Sprintf("%d\n", i+1))
		sb.WriteString(fmt.Sprintf("%s --> %s\n", formatSRTTime(line.Start), formatSRTTime(line.End())))
		sb.WriteString(line.Text)
		sb.WriteString("\n\n")
	}
	return sb.String()
}

// ToVTT converts the caption data to WebVTT format.
func (cd *CaptionData) ToVTT() string {
	var sb strings.Builder
	sb.WriteString("WEBVTT\n\n")
	for i, line := range cd.Lines {
		sb.WriteString(fmt.Sprintf("%d\n", i+1))
		sb.WriteString(fmt.Sprintf("%s --> %s\n", formatVTTTime(line.Start), formatVTTTime(line.End())))
		sb.WriteString(line.Text)
		sb.WriteString("\n\n")
	}
	return sb.String()
}

// formatSRTTime formats a time in seconds to SRT timestamp format (HH:MM:SS,mmm).
func formatSRTTime(seconds float64) string {
	h := int(seconds / 3600)
	m := int(seconds/60) % 60
	s := int(seconds) % 60
	ms := int((seconds - float64(int(seconds))) * 1000)
	return fmt.Sprintf("%02d:%02d:%02d,%03d", h, m, s, ms)
}

// formatVTTTime formats a time in seconds to WebVTT timestamp format (HH:MM:SS.mmm).
func formatVTTTime(seconds float64) string {
	h := int(seconds / 3600)
	m := int(seconds/60) % 60
	s := int(seconds) % 60
	ms := int((seconds - float64(int(seconds))) * 1000)
	return fmt.Sprintf("%02d:%02d:%02d.%03d", h, m, s, ms)
}

// CaptionDownloader downloads and parses YouTube captions.
type CaptionDownloader struct {
	// Client is the HTTP client to use for requests.
	Client *http.Client
}

// NewCaptionDownloader creates a new CaptionDownloader with the given HTTP client.
func NewCaptionDownloader(client *http.Client) *CaptionDownloader {
	if client == nil {
		client = http.DefaultClient
	}
	return &CaptionDownloader{Client: client}
}

// Download fetches the caption track content and parses it into CaptionData.
func (d *CaptionDownloader) Download(ctx context.Context, track *CaptionTrack) (*CaptionData, error) {
	if track == nil || track.URL == "" {
		return nil, fmt.Errorf("invalid caption track: URL is empty")
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, track.URL, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	resp, err := d.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("fetching caption: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading response: %w", err)
	}

	return ParseCaptionXML(body)
}

// DownloadAsSRT downloads the caption track and returns it as SRT format.
func (d *CaptionDownloader) DownloadAsSRT(ctx context.Context, track *CaptionTrack) (string, error) {
	data, err := d.Download(ctx, track)
	if err != nil {
		return "", err
	}
	return data.ToSRT(), nil
}

// DownloadAsVTT downloads the caption track and returns it as WebVTT format.
func (d *CaptionDownloader) DownloadAsVTT(ctx context.Context, track *CaptionTrack) (string, error) {
	data, err := d.Download(ctx, track)
	if err != nil {
		return "", err
	}
	return data.ToVTT(), nil
}

// xmlTranscript represents the root element of YouTube's caption XML format.
type xmlTranscript struct {
	XMLName xml.Name  `xml:"transcript"`
	Texts   []xmlText `xml:"text"`
}

// xmlText represents a single caption text element.
type xmlText struct {
	Start string `xml:"start,attr"`
	Dur   string `xml:"dur,attr"`
	Text  string `xml:",chardata"`
}

// ParseCaptionXML parses YouTube's XML caption format into CaptionData.
func ParseCaptionXML(data []byte) (*CaptionData, error) {
	var transcript xmlTranscript
	if err := xml.Unmarshal(data, &transcript); err != nil {
		return nil, fmt.Errorf("parsing caption XML: %w", err)
	}

	captionData := &CaptionData{
		Lines: make([]CaptionLine, 0, len(transcript.Texts)),
	}

	for _, text := range transcript.Texts {
		start, err := strconv.ParseFloat(text.Start, 64)
		if err != nil {
			continue // Skip lines with invalid timing
		}

		dur, _ := strconv.ParseFloat(text.Dur, 64)
		if dur <= 0 {
			dur = 2.0 // Default duration if not specified
		}

		// Decode HTML entities in the text
		decodedText := html.UnescapeString(text.Text)

		captionData.Lines = append(captionData.Lines, CaptionLine{
			Start:    start,
			Duration: dur,
			Text:     decodedText,
		})
	}

	return captionData, nil
}
