package youtube

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"regexp"
	"strconv"
	"strings"
	"time"
)

const (
	// youtubeBaseURL is the base URL for YouTube.
	youtubeBaseURL = "https://www.youtube.com"

	// bpctr parameter value to bypass content restriction checks.
	bpctrValue = "9999999999"
)

// WatchPage represents a fetched YouTube video watch page.
type WatchPage struct {
	// VideoID is the video ID this page was fetched for.
	VideoID string

	// HTML is the raw HTML content of the page.
	HTML string
}

// WatchPageFetcher fetches YouTube video watch pages.
type WatchPageFetcher struct {
	// Client is the HTTP client to use for requests.
	Client *http.Client

	// BaseURL is the base URL for YouTube (used for testing).
	// If empty, defaults to https://www.youtube.com.
	BaseURL string
}

// WatchPageURL returns the URL for a video's watch page.
// The bpctr parameter is included to bypass content restriction checks.
func WatchPageURL(videoID string) string {
	return fmt.Sprintf("%s/watch?v=%s&bpctr=%s", youtubeBaseURL, videoID, bpctrValue)
}

// Fetch retrieves the watch page HTML for a given video ID.
func (f *WatchPageFetcher) Fetch(ctx context.Context, videoID string) (*WatchPage, error) {
	baseURL := f.BaseURL
	if baseURL == "" {
		baseURL = youtubeBaseURL
	}

	watchURL := fmt.Sprintf("%s/watch?v=%s&bpctr=%s", baseURL, videoID, bpctrValue)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, watchURL, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	resp, err := f.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("fetching watch page: %w", err)
	}
	defer func() {
		_ = resp.Body.Close()
	}()

	if resp.StatusCode == http.StatusTooManyRequests {
		return nil, &RateLimitError{Message: "YouTube returned 429 Too Many Requests"}
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading response body: %w", err)
	}

	return &WatchPage{
		VideoID: videoID,
		HTML:    string(body),
	}, nil
}

// RateLimitError is returned when YouTube rate limits the request.
type RateLimitError struct {
	Message string
}

func (e *RateLimitError) Error() string {
	return fmt.Sprintf("rate limit exceeded: %s", e.Message)
}

// VideoUnavailableError is returned when a video is not available.
type VideoUnavailableError struct {
	VideoID string
	Reason  string
}

func (e *VideoUnavailableError) Error() string {
	return fmt.Sprintf("video '%s' is unavailable: %s", e.VideoID, e.Reason)
}

// PlayerResponse represents the ytInitialPlayerResponse JSON structure
// embedded in YouTube watch pages.
type PlayerResponse struct {
	VideoDetails      VideoDetailsResponse      `json:"videoDetails"`
	PlayabilityStatus PlayabilityStatusResponse `json:"playabilityStatus"`
	StreamingData     *StreamingDataResponse    `json:"streamingData,omitempty"`
	Captions          *CaptionsResponse         `json:"captions,omitempty"`
}

// CaptionsResponse contains caption track information from the player response.
type CaptionsResponse struct {
	PlayerCaptionsTracklistRenderer *PlayerCaptionsTracklistRenderer `json:"playerCaptionsTracklistRenderer,omitempty"`
}

// PlayerCaptionsTracklistRenderer contains the list of caption tracks.
type PlayerCaptionsTracklistRenderer struct {
	CaptionTracks []CaptionTrackResponse `json:"captionTracks,omitempty"`
}

// CaptionTrackResponse represents a single caption track from the player response.
type CaptionTrackResponse struct {
	BaseURL        string          `json:"baseUrl"`
	VssID          string          `json:"vssId"`
	LanguageCode   string          `json:"languageCode"`
	Kind           string          `json:"kind,omitempty"`
	Name           CaptionNameText `json:"name"`
	IsTranslatable bool            `json:"isTranslatable"`
}

// CaptionNameText holds the caption track name.
type CaptionNameText struct {
	SimpleText string `json:"simpleText"`
}

// ExtractCaptionManifest extracts caption tracks from the player response
// and returns a CaptionManifest containing all available tracks.
func (pr *PlayerResponse) ExtractCaptionManifest() *CaptionManifest {
	manifest := &CaptionManifest{
		Tracks: []CaptionTrack{},
	}

	if pr.Captions == nil || pr.Captions.PlayerCaptionsTracklistRenderer == nil {
		return manifest
	}

	for _, track := range pr.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks {
		captionTrack := CaptionTrack{
			URL:             track.BaseURL,
			LanguageCode:    track.LanguageCode,
			LanguageName:    track.Name.SimpleText,
			IsAutoGenerated: track.Kind == "asr",
			IsTranslatable:  track.IsTranslatable,
		}
		manifest.Tracks = append(manifest.Tracks, captionTrack)
	}

	return manifest
}

// VideoDetailsResponse contains basic video metadata from the player response.
type VideoDetailsResponse struct {
	VideoID          string   `json:"videoId"`
	Title            string   `json:"title"`
	LengthSeconds    string   `json:"lengthSeconds"`
	Keywords         []string `json:"keywords"`
	ChannelID        string   `json:"channelId"`
	ShortDescription string   `json:"shortDescription"`
	Thumbnail        struct {
		Thumbnails []ThumbnailResponse `json:"thumbnails"`
	} `json:"thumbnail"`
	ViewCount         string `json:"viewCount"`
	Author            string `json:"author"`
	IsLiveContent     bool   `json:"isLiveContent"`
	IsPrivate         bool   `json:"isPrivate"`
	IsUnpluggedCorpus bool   `json:"isUnpluggedCorpus"`
}

// ThumbnailResponse represents a thumbnail image from the player response.
type ThumbnailResponse struct {
	URL    string `json:"url"`
	Width  int    `json:"width"`
	Height int    `json:"height"`
}

// PlayabilityStatusResponse contains information about video availability.
type PlayabilityStatusResponse struct {
	Status          string `json:"status"`
	Reason          string `json:"reason,omitempty"`
	PlayableInEmbed bool   `json:"playableInEmbed"`
}

// StreamingDataResponse contains the streaming formats and manifest URLs.
type StreamingDataResponse struct {
	ExpiresInSeconds string           `json:"expiresInSeconds"`
	Formats          []FormatResponse `json:"formats"`
	AdaptiveFormats  []FormatResponse `json:"adaptiveFormats"`
	DashManifestURL  string           `json:"dashManifestUrl,omitempty"`
	HlsManifestURL   string           `json:"hlsManifestUrl,omitempty"`
}

// GetStreamManifest parses the streaming data and returns a StreamManifest
// containing all available video and audio streams.
func (sd *StreamingDataResponse) GetStreamManifest() *StreamManifest {
	manifest := &StreamManifest{
		VideoStreams: []VideoStreamInfo{},
		AudioStreams: []AudioStreamInfo{},
		MuxedStreams: []MuxedStreamInfo{},
	}

	// Process adaptive formats (video-only and audio-only)
	for i := range sd.AdaptiveFormats {
		format := &sd.AdaptiveFormats[i]
		container, codec := parseMimeType(format.MimeType)

		if isVideoFormat(format.MimeType) {
			vs := VideoStreamInfo{
				StreamInfo: StreamInfo{
					URL:           format.URL,
					Quality:       format.QualityLabel,
					Bitrate:       format.Bitrate,
					Codec:         codec,
					Container:     container,
					MimeType:      format.MimeType,
					ContentLength: parseContentLength(format.ContentLength),
				},
				Width:      format.Width,
				Height:     format.Height,
				Framerate:  format.Fps,
				VideoCodec: codec,
			}
			// Use calculated quality if none provided
			if vs.Quality == "" && format.Height > 0 {
				vs.Quality = QualityLabel(format.Height)
			}
			manifest.VideoStreams = append(manifest.VideoStreams, vs)
		} else if isAudioFormat(format.MimeType) {
			as := AudioStreamInfo{
				StreamInfo: StreamInfo{
					URL:           format.URL,
					Quality:       format.AudioQuality,
					Bitrate:       format.Bitrate,
					Codec:         codec,
					Container:     container,
					MimeType:      format.MimeType,
					ContentLength: parseContentLength(format.ContentLength),
				},
				AudioCodec:   codec,
				SampleRate:   parseSampleRate(format.AudioSampleRate),
				ChannelCount: format.AudioChannels,
			}
			manifest.AudioStreams = append(manifest.AudioStreams, as)
		}
	}

	// Process muxed formats (video+audio combined)
	for i := range sd.Formats {
		format := &sd.Formats[i]
		container, codec := parseMimeType(format.MimeType)
		videoCodec, audioCodec := parseCodecs(codec)

		ms := MuxedStreamInfo{
			VideoStreamInfo: VideoStreamInfo{
				StreamInfo: StreamInfo{
					URL:           format.URL,
					Quality:       format.QualityLabel,
					Bitrate:       format.Bitrate,
					Codec:         codec,
					Container:     container,
					MimeType:      format.MimeType,
					ContentLength: parseContentLength(format.ContentLength),
				},
				Width:      format.Width,
				Height:     format.Height,
				Framerate:  format.Fps,
				VideoCodec: videoCodec,
			},
			AudioStreamInfo: AudioStreamInfo{
				AudioCodec: audioCodec,
			},
		}
		manifest.MuxedStreams = append(manifest.MuxedStreams, ms)
	}

	return manifest
}

// parseMimeType extracts the container and codec from a MIME type string.
// Example: "video/mp4; codecs=\"avc1.640028\"" -> "mp4", "avc1.640028"
func parseMimeType(mimeType string) (container Container, codec string) {
	// Extract container from the main type
	switch {
	case strings.HasPrefix(mimeType, "video/mp4"), strings.HasPrefix(mimeType, "audio/mp4"):
		container = ContainerMP4
	case strings.HasPrefix(mimeType, "video/webm"), strings.HasPrefix(mimeType, "audio/webm"):
		container = ContainerWebM
	case strings.HasPrefix(mimeType, "video/3gpp"):
		container = Container3GP
	}

	// Extract codec from the codecs parameter
	codecStart := strings.Index(mimeType, "codecs=\"")
	if codecStart == -1 {
		return container, ""
	}
	codecStart += len("codecs=\"")
	codecEnd := strings.Index(mimeType[codecStart:], "\"")
	if codecEnd == -1 {
		return container, ""
	}

	codec = mimeType[codecStart : codecStart+codecEnd]
	return container, codec
}

// parseCodecs splits a combined codec string into video and audio codecs.
// Example: "avc1.42001E, mp4a.40.2" -> "avc1.42001E", "mp4a.40.2"
func parseCodecs(codec string) (videoCodec, audioCodec string) {
	parts := strings.Split(codec, ", ")
	if len(parts) >= 2 {
		return strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])
	}
	return codec, ""
}

// isVideoFormat checks if the MIME type represents a video format.
func isVideoFormat(mimeType string) bool {
	return strings.HasPrefix(mimeType, "video/")
}

// isAudioFormat checks if the MIME type represents an audio format.
func isAudioFormat(mimeType string) bool {
	return strings.HasPrefix(mimeType, "audio/")
}

// parseContentLength parses a content length string to int64.
func parseContentLength(s string) int64 {
	if s == "" {
		return 0
	}
	val, _ := strconv.ParseInt(s, 10, 64)
	return val
}

// parseSampleRate parses a sample rate string to int.
func parseSampleRate(s string) int {
	if s == "" {
		return 0
	}
	val, _ := strconv.Atoi(s)
	return val
}

// FormatResponse represents a single stream format.
type FormatResponse struct {
	Itag             int    `json:"itag"`
	URL              string `json:"url,omitempty"`
	MimeType         string `json:"mimeType"`
	Bitrate          int64  `json:"bitrate"`
	Width            int    `json:"width,omitempty"`
	Height           int    `json:"height,omitempty"`
	ContentLength    string `json:"contentLength,omitempty"`
	Quality          string `json:"quality"`
	QualityLabel     string `json:"qualityLabel,omitempty"`
	Fps              int    `json:"fps,omitempty"`
	AudioQuality     string `json:"audioQuality,omitempty"`
	AudioSampleRate  string `json:"audioSampleRate,omitempty"`
	AudioChannels    int    `json:"audioChannels,omitempty"`
	SignatureCipher  string `json:"signatureCipher,omitempty"`
	AverageBitrate   int64  `json:"averageBitrate,omitempty"`
	ApproxDurationMs string `json:"approxDurationMs,omitempty"`
}

// NeedsCipherDecryption returns true if this stream requires signature cipher decryption
// to obtain a playable URL.
func (f *FormatResponse) NeedsCipherDecryption() bool {
	return f.URL == "" && f.SignatureCipher != ""
}

// SignatureCipher represents the parsed components of a YouTube signature cipher.
type SignatureCipher struct {
	// URL is the base URL for the stream (without the signature).
	URL string

	// SignatureParam is the query parameter name for the signature (usually "sig" or "signature").
	SignatureParam string

	// Signature is the encrypted signature that needs to be decrypted.
	Signature string
}

// BuildURL constructs the full playable URL by appending the decrypted signature.
func (sc *SignatureCipher) BuildURL() string {
	return sc.URL + "&" + sc.SignatureParam + "=" + sc.Signature
}

// ErrInvalidSignatureCipher is returned when the signature cipher string is malformed.
var ErrInvalidSignatureCipher = errors.New("invalid signature cipher format")

// ParseSignatureCipher parses a YouTube signatureCipher string into its components.
// The format is: s=<encrypted_signature>&sp=<signature_param>&url=<url_encoded_url>
func ParseSignatureCipher(cipher string) (*SignatureCipher, error) {
	if cipher == "" {
		return nil, ErrInvalidSignatureCipher
	}

	// Parse the query string
	values, err := url.ParseQuery(cipher)
	if err != nil {
		return nil, fmt.Errorf("parsing signature cipher: %w", err)
	}

	// Extract signature (required)
	signature := values.Get("s")
	if signature == "" {
		return nil, fmt.Errorf("%w: missing signature (s)", ErrInvalidSignatureCipher)
	}

	// Extract URL (required)
	streamURL := values.Get("url")
	if streamURL == "" {
		return nil, fmt.Errorf("%w: missing URL", ErrInvalidSignatureCipher)
	}

	// Extract signature parameter name (optional, defaults to "signature")
	signatureParam := values.Get("sp")
	if signatureParam == "" {
		signatureParam = "signature"
	}

	return &SignatureCipher{
		URL:            streamURL,
		SignatureParam: signatureParam,
		Signature:      signature,
	}, nil
}

// ErrPlayerResponseNotFound is returned when ytInitialPlayerResponse is not found in the page.
var ErrPlayerResponseNotFound = errors.New("ytInitialPlayerResponse not found in page")

// ToVideo converts the PlayerResponse to a Video struct.
func (pr *PlayerResponse) ToVideo() (*Video, error) {
	vd := pr.VideoDetails

	// Parse duration
	durationSeconds, err := strconv.ParseInt(vd.LengthSeconds, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("parsing duration: %w", err)
	}

	// Parse view count (ignore errors, default to 0)
	viewCount, _ := strconv.ParseInt(vd.ViewCount, 10, 64)

	// Convert thumbnails
	thumbnails := make([]Thumbnail, len(vd.Thumbnail.Thumbnails))
	for i, t := range vd.Thumbnail.Thumbnails {
		thumbnails[i] = Thumbnail(t)
	}

	// Build channel URL
	channelURL := fmt.Sprintf("%s/channel/%s", youtubeBaseURL, vd.ChannelID)

	return &Video{
		ID:          vd.VideoID,
		Title:       vd.Title,
		Description: vd.ShortDescription,
		Duration:    time.Duration(durationSeconds) * time.Second,
		ViewCount:   viewCount,
		Keywords:    vd.Keywords,
		Thumbnails:  thumbnails,
		IsLive:      vd.IsLiveContent,
		IsPrivate:   vd.IsPrivate,
		Author: Author{
			Name:      vd.Author,
			ChannelID: vd.ChannelID,
			URL:       channelURL,
		},
	}, nil
}

// ExtractPlayerResponse extracts and parses the ytInitialPlayerResponse JSON
// from the watch page HTML.
func (p *WatchPage) ExtractPlayerResponse() (*PlayerResponse, error) {
	// Use a more robust regex that handles nested JSON properly
	// We need to find the JSON object that starts after "var ytInitialPlayerResponse = "
	// and ends before the next script boundary

	// First, try to find the start of the player response
	startPattern := regexp.MustCompile(`var\s+ytInitialPlayerResponse\s*=\s*`)
	startLoc := startPattern.FindStringIndex(p.HTML)
	if startLoc == nil {
		return nil, ErrPlayerResponseNotFound
	}

	// Find where the JSON object starts (after the "=")
	jsonStart := startLoc[1]

	// Now we need to find the matching closing brace
	// We'll use a bracket counting approach for proper JSON extraction
	jsonStr, err := extractJSONObject(p.HTML[jsonStart:])
	if err != nil {
		return nil, fmt.Errorf("extracting JSON: %w", err)
	}

	var response PlayerResponse
	if err := json.Unmarshal([]byte(jsonStr), &response); err != nil {
		return nil, fmt.Errorf("parsing player response JSON: %w", err)
	}

	return &response, nil
}

// extractJSONObject extracts a complete JSON object from the start of a string.
// It handles nested objects and arrays by counting braces.
func extractJSONObject(s string) (string, error) {
	if s == "" || s[0] != '{' {
		return "", errors.New("string does not start with '{'")
	}

	depth := 0
	inString := false
	escaped := false

	for i, c := range s {
		if escaped {
			escaped = false
			continue
		}

		if c == '\\' && inString {
			escaped = true
			continue
		}

		if c == '"' {
			inString = !inString
			continue
		}

		if inString {
			continue
		}

		switch c {
		case '{':
			depth++
		case '}':
			depth--
			if depth == 0 {
				return s[:i+1], nil
			}
		}
	}

	return "", errors.New("unbalanced braces in JSON")
}
